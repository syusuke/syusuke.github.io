<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[杭电ACM-Fibonacci数列]]></title>
      <url>%2F2017%2F02%2F03%2F%E6%9D%AD%E7%94%B5ACM-Fibonacci%E6%95%B0%E5%88%97%2F</url>
      <content type="text"><![CDATA[杭电ACM-Fibonacci数列这文章是我在[2014-11-22 18:58:24]写的,现在移到这个博客里的:原文地址 例如 费波那契数列（意大利语：Successione di Fibonacci），又译为费波拿契数、斐波那契数列、费氏数列、黄金分割数列。 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233 F0 = 0 F1 = 1 F2 = F(n-1)+F(n-2) [n&gt;=2] 这里的数比较大,所以,只要是小的数,就可以用递归来做,这里用到了 这个数列的一个公式: 由于题目要求,高于4位的输出四位,如果小于4位的数(小于1000)的数,也是可以用的,只是直接输出比较麻烦,所以,我们就可以,把小于4位的数直接输出,如果刚好是4位的(小于9999)的.如果也是通过递归算的,计算量比较大 代码如下12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;iomanip&gt;using namespace std;int fibo(int i)&#123; if (i == 0) return 0; else if (i == 1) return 1; return fibo(i - 1) + fibo(i - 2);&#125;int main()&#123; int n; while (cin &gt;&gt; n) &#123; //小于20 的直接算就可以 if (n&lt;=20) cout &lt;&lt; fibo(n) &lt;&lt; endl; else &#123; //大于20的,直接用公式 double a1 = -0.5*log10(5.0); double a2 = (1.0 + sqrt(5.0)) / 2.0; double a3 = n*log10(a2); a2 = a1 + a3; a2 = a2 - int(a2); double b = pow(10.0, a2); cout &lt;&lt; (int)(b*1000) &lt;&lt; endl; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[杭电ACM-Wooden Sticks]]></title>
      <url>%2F2016%2F12%2F24%2F%E6%9D%AD%E7%94%B5ACM-Wooden-Sticks%2F</url>
      <content type="text"><![CDATA[杭电ACM-Wooden Sticks这文章是我在[2014-11-26 09:06:52]写的,现在移到这个博客里的:原文地址 题目Wooden Sticks Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 2322 Accepted Submission(s): 905 Problem DescriptionThere is a pile of n wooden sticks. The length and weight of each stick are known in advance. The sticks are to be processed by a woodworking machine in one by one fashion. It needs some time, called setup time, for the machine to prepare processing a stick. The setup times are associated with cleaning operations and changing tools and shapes in the machine. The setup times of the woodworking machine are given as follows: (a) The setup time for the first wooden stick is 1 minute. (b) Right after processing a stick of length l and weight w , the machine will need no setup time for a stick of length l’ and weight w’ if l&lt;=l’ and w&lt;=w’. Otherwise, it will need 1 minute for setup. You are to find the minimum setup time to process a given pile of n wooden sticks. For example, if you have five sticks whose pairs of length and weight are (4,9), (5,2), (2,1), (3,5), and (1,4), then the minimum setup time should be 2 minutes since there is a sequence of pairs (1,4), (3,5), (4,9), (2,1), (5,2). InputThe input consists of T test cases. The number of test cases (T) is given in the first line of the input file. Each test case consists of two lines: The first line has an integer n , 1&lt;=n&lt;=5000, that represents the number of wooden sticks in the test case, and the second line contains n 2 positive integers l1, w1, l2, w2, …, ln, wn, each of magnitude at most 10000 , where li and wi are the length and weight of the i th wooden stick, respectively. The 2n integers are delimited by one or more spaces. OutputThe output should contain the minimum setup time in minutes, one per line. Sample Input354 9 5 2 2 1 3 5 1 432 2 1 1 2 231 3 2 2 3 1 Sample Output213 SourceAsia 2001, Taejon (South Korea) 我的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//锯木时间问题/* 我是先按长度排序,然后再先择重量符合要求,然后交换*/#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct Wooden&#123; int length; int weigth;&#125;;bool cmp(const Wooden &amp;a, const Wooden &amp;b)&#123; if (a.length != b.length) return a.length &lt; b.length; else return a.weigth &lt; b.weigth;&#125;int main()&#123; int T, n; Wooden ws[5001]; int flag[5001]; //标志是否被访问过 cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; ws[i].length &gt;&gt; ws[i].weigth; flag[i] = 0; &#125; sort(ws, ws + n, cmp); int time = 0; for (int i = 0; i &lt; n ; i++) &#123; if (flag[i] == 1) //跳过已经被访问过的元素 continue; int tempW = ws[i].weigth; for (int j = i + 1; j &lt; n; j++) &#123; //下面就是从以后的元素找重量最小的那个,类似于先择排序法 if (tempW &lt;= ws[j].weigth &amp;&amp; (flag[j] == 0)) &#123; tempW = ws[j].weigth; flag[j] = 1; &#125; &#125; time++; &#125; cout &lt;&lt; time &lt;&lt; endl; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android艺术探索第一章]]></title>
      <url>%2F2016%2F11%2F19%2FAndroid%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%AC%E4%B8%80%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[一.生命周期 onCreate: 初始化工作 onStart: 已经可见,但是没在前台,无法交互 onResume:已经可见而且可以交互 onPause: Activity正在停止,正常情况下onStop()会紧接着执行,如果快速再次回到Activity,就会执行onResume方法,这种情况比较极端.这里不适合耗时操作,可以存储数据,停止动画等操作, onStop: 即将停止.不能耗时操作 onDestory: Activity 就要被销毁,这是最后一个回调,做为资源的回收和资源的释放. onRestart: Activity正在启动,从从不可见变为可见 1.1 正常下的生命周期(1).第一次启动onCreate-&gt;onStart-&gt;onResume (2).打开新Activity或者Home时.onPause-&gt;onStop PS:新Activity 透明的主题,那么旧的Activity的onStop不会被执行 (3).再次回到ActivityonRestart-&gt;onStart-&gt;onResume (4).back键时onPause-&gt;onStop-&gt;onDestory onCreate &lt;=&gt; onDestory :Activity 的 创建 销毁 onStart &lt;=&gt; onStop Activity 可见上来说 onResume &lt;=&gt; onPause Activity 是否在前台 Activity A 启动 Activity B 的 生命周期 A:onPause B:onCreate B:onStart B:onResume A:onStop 1.2 异常下的生命周期 Configuration发生改变 (1)资源配置发生改变配置发生改变: Activity-&gt;意外发生-&gt;执行onSaveInstanceState-&gt;onDestoryonSaveInstanceState: 在onStop之前,但onPause之前或之后,都有可能 重建Activity: Activity-&gt;onCreate-&gt;onRestoreInstanceStateonRestoreInstanceState : 在onStart之后 (2)系统内存不足Activity优先级: 前台Activity 可见Activity,但非前台Activity,如Dialog 后台Activity 也可指定当系统配置发生改变时,不重建 Activity 常用配置locale | orientation| keyboardHidden123&lt;activityandorid:configChanges=&quot;locale|orientation|keyboardHidden&quot;&gt;&lt;/activity&gt; 二.Activity启动模式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello Hexo]]></title>
      <url>%2F2016%2F11%2F19%2Fhello-hexo%2F</url>
      <content type="text"><![CDATA[安装按照官网就可以我选择的主题是:next Config12345678910111213141516// Sitetitle: 琴声悠扬subtitle: As An Developer!description: 当你孤单你会想起谁?author: 琴声悠扬language: zh-Hanstimezone: Asia/Shanghaiavatar: /images/avatar.png 1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 创建tags,categories生成index.htmlhexo new page &quot;tags&quot;title: Tagcloud date: 2014-12-22 12:39:04 type: “tags” hexo new page &quot;categories&quot;title: Tagcloud date: 2014-12-22 12:39:04 type: “categories” 注意打开menu菜单下的注释 hexo ghexo d 就可以了.]]></content>
    </entry>

    
  
  
</search>
