<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[1.Spring-Bean-DI]]></title>
      <url>%2F2017%2F02%2F18%2F1-Spring-Bean-DI%2F</url>
      <content type="text"><![CDATA[Spring依赖注入 接口注入 set注入 构造注入 12345&lt;bean id="hw" class="com.gson8.action.hw"&gt; &lt;constructor-arg index="0"&gt; &lt;value&gt;Hello World&lt;/value&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; constructor-arg: 表示构造方法注入 index: 表示参数的个数 注入方式的选择 构造注入可以在构建对象的同时一并完成依赖关系主的建立, 这个对象的关系也就准备好了. 如果在建立的关系过多, 使用构造方式注入,会使得参数太长, set 要写好关系的名字,方便区分 Bean基础知识bean最基本,最重要的两个包: org.springframework.beans org.springframework.context 最重要的两个类: BeanFactory 配置管理任何类的Bean ApplicationContext 国际化,获取资源,事件传递 123456789package com.gson8.sp;public class BidBean&#123; private String msg=null; private Date date=null; public BidBean(String msg)&#123; this.msg = msg; &#125;&#125; 1234567&lt;beans&gt; &lt;bean id="BidBean" class="com.gson8.sp"&gt; &lt;property name="msg"&gt; &lt;value&gt;this is a test&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 或者使用name来指定Bean的ID 1234567&lt;beans&gt; &lt;bean name="BidBean" class="com.gson8.sp"&gt; &lt;property name="msg"&gt; &lt;value&gt;this is a test&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Bean默认使用单例模式, 只会创建一次 123456&lt;!-- false:不使用单例模式, true:默认使用 --&gt;&lt;bean name="BidBean" class="com.gson8.sp" singleton="true/false"&gt; &lt;property name="msg"&gt; &lt;value&gt;this is a test&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; Bean的属性Bean的注入方式 set注入 调用无参的构造方法, 调用无参的静态工厂方法 构造注入 有参的构造方法 config.xml 12345678910111213&lt;beans&gt; &lt;bean id="BidBean" class="...."&gt; &lt;property name="msg"&gt; &lt;value&gt;Hw&lt;/value&gt; &lt;/property&gt; &lt;property name="date"&gt; &lt;!--1.方式:意思为参考了 id=date 的Bean--&gt; &lt;ref name="date"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- id = 'date' --&gt; &lt;bean id="date" class="java.util.Date"/&gt;&lt;/beans&gt; //OR 1234567891011&lt;beans&gt; &lt;bean id="BidBean" class="...."&gt; &lt;property name="msg"&gt; &lt;value&gt;Hw&lt;/value&gt; &lt;/property&gt; &lt;property name="date"&gt; &lt;!--1.方式:意思为参考了 id=date 的Bean--&gt; &lt;bean id="date" class="java.util.Date"/&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; null 处理 12345678//1&lt;property&gt; &lt;value&gt;null&lt;/value&gt;&lt;/property&gt;//2&lt;property&gt; &lt;null/&gt;&lt;/property&gt; 上面这两种跟 String msg = null ; 等价 Test.java12345public static void main(String[] args)&#123; ApplicationContext actx = new FileSystemXmlApplicationContext("config.xml"); BidBean bid = actx.getBean("BidBean"); System.out.println(bid.getDate()+":"+bid.getMsg());&#125; depends-on 如果想要一个Bean初始化之前强制Init 另一个或多个其他Bean 123//表示在这个 Bean 初始化之前,强制初始化 date&lt;bean id="XXX" class="XXXX" depends-on="date"&gt;&lt;/bean&gt; Bean的生命周期init-method 属性 123456789public class Bean&#123; private String msg =null; private Date date = null; //Config.xml方法 public void init()&#123; msg = "HWWWWW"; date = new Date(); &#125;&#125; 123&lt;bean id="" class="" init-method="init"&gt; ...&lt;/bean&gt; 实现接口:org.springframework.beans.factory.InitializingBean 123456789public class Bean implements InitializingBean &#123; private String msg =null; private Date date = null; //Add Method public void afterProperitiesSet()&#123; msg = "HWWWWW"; date = new Date(); &#125;&#125; Bean 的使用方式(1). BeanWrapper(推荐)1234BidBean bid = new BidBean();BeanWrapper bw = new BeanWrapper(bid);bw.setPropertyValue("msg","LOVE YOU");System.out.println(bw.getPropertyValue("msg")); (2). BeanFactory1234InputStream is = new FileSystemStream("config.xml");XmlBeanFactory factory = new XmlBeanFactory(is);BidBean bid = (BidBea)factory.getBean("BidBean"); //By IDSystem.out.println(bid.getMsg()); (3). ApplicationContext123ApplicationContext actx = new FileSystemXmlApplicationContext("config.xml");BidBean bid = (BidBean)actx.getBean("BidBean"); //By Bean IDSystem.out.println(bid.getMsg()); 对比: 对于BeanFactory来说,ApplicationContext 除了提供前者所有功能外,还有一些基本的功能, 国际化的支持,资源访问, 事件传递. Bean的destory config.xml中指定destory-method=”destory” 实现 org.springframework.beans.factory.DisposableBean ref 的实现方式local,Bean,parent12345678910111213&lt;beans&gt; &lt;bean id="BidBean" class="XXX"&gt; &lt;property&gt; &lt;!-- local: 同一个文件中,使用 local --&gt; &lt;ref local="date"/&gt; &lt;!-- bean: 可以在同一个文件中,也可以不在同一个文件中 --&gt; &lt;ref bean="date"/&gt; &lt;!-- parent: 引用当前ApplicationContext/BeanFactory的父ApplicationContext/BeanFactory中的Bean--&gt; &lt;ref parent="date"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="date" class="java.util.Date"&gt;&lt;/bean&gt;&lt;/beans&gt; 比较 local &amp; bean 相同: 都可以用Bean的ID进行引用参考,都可以对同一XML进行参考引用 不同: Bean属性可以通过name进行参考引用, 还可以对不同的XML进行引用 Bean的装载模式 config.xml:autowire=&quot;XXXX&quot; byName: byType constructor autodetect no: (不推荐) Bean的4种依赖检查模式 dependency-check : “” 1234&lt;beans&gt; &lt;bean id="" class="" autowire="autodetect" dependency-check="simple/object/all/none"&gt; &lt;/bean&gt;&lt;/beans&gt; simple: 是指Bean的属性为基本数据类型,字符串,集合进行依赖检查 object: 是指Bean的属性为Object,对Object进行依赖检查 all: 全部属性 none: 不进行依赖检查 集合的注入方式 List, Set ,Map, Properties 123456public class Collect&#123; private List lists; private Set sets; private Map map; private Properties propties;&#125; config.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;beans&gt; &lt;bean id="" class="" ...&gt; &lt;property name="lists"&gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;property name="sets"&gt; &lt;set&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;4&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="gf"&gt; &lt;value&gt;ABC&lt;/value&gt; &lt;/entry&gt; &lt;entry key="bf"&gt; &lt;value&gt;ABC&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="propties"&gt; &lt;props&gt; &lt;prop key="fd"&gt;abbc&lt;/prop&gt; &lt;prop key="bg"&gt;abbc&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/beans&gt; ApplicationContext国际化 message.properties文件放到WEB-INF/src下 msg=FUCK{0},NOW{1} //参数 ApplicationContext获取资源方式 CLASSPATH,虚拟路径 123ApplicationContext actx = new FileSystemXmlApplicationContext("config.xml");//classpath:是Spring的URL虚拟路径Resuource res = actx.getResuource("classpath:message.properties"); 实际路径,file:&amp;http: 12ApplicationContext actx = new FileSystemXmlApplicationContext("config.xml");Resource res = actx.getResource("file:d:/java/Pro/WEB-INF/src/message.properties"); 相对路径 12ApplicationContext atx = new FileSystemXmlApplicationContext("config.xml");Resouce res = atx.getResource("WEB-INF/src/message.properties"); ApplicationContext事件传递LogEvent.java 123456package com.gson8.action;public class LogEvent extends ApplicationEvent&#123; public LogEvent(Object obj)&#123; super(obj); &#125;&#125; LogListener.java 1234567891011package com.gson8.action;public class LogListener implements ApplicationListener&#123; public void onApplicationEvent(ApplicationEvent event)&#123; if(event instanceof LogEvent)&#123; SimpleDateFormat sdf = new SimpleDateFormat("YYYY-MM-dd HH:mm:ss"); sdf.setLenient(false); String curDate = sdf.format(new Date()); System.out.prinfln("time:"+curDate+",msg:"+event.toString()); &#125; &#125;&#125; Log.java 123456789101112package com.gson8.action;public class Log implements ApplicationContextAwre&#123; private ApplicationContext aptx; public void setApplicationContext(ApplicationContext actx)&#123; this.aptx = actx; &#125; public void log(String log)&#123; LogEvent le = new LogEvent(log); this.aptx.publicEvent(le); return 0; &#125;&#125; config.xml 1234567891011&lt;beans&gt; &lt;!--国际化--&gt; &lt;bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource"&gt; &lt;property name="basename"&gt; &lt;value&gt;message&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--事件传递--&gt; &lt;bean id="log" class="com.gson8.action.Log"/&gt; &lt;bean id="listener" class="com.gson8.action.LogListener"/&gt;&lt;/beans&gt; log.log() -&gt; LogEvent.class -&gt; ApplicationContext.publicEvent(logEvent) -&gt; LogListener]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP字符串相关]]></title>
      <url>%2F2017%2F02%2F07%2FPHP%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%2F</url>
      <content type="text"><![CDATA[编码问题1header('content-type:text/html;charset=utf-8'); 单引号与双引号的区别 双引号解析变量:”” 单引号效率高一点,不用解析变量 1234$username = "abc";echo "我的名字是$username";//我的名字是abcecho "我的名字是&#123;$username&#125;s";//我的名字是abcecho "我的名字是$&#123;username&#125;s"//我的名字是abc {} 的另一个作用12345678910111213$str = 'abcdef';//查找echo $str&#123;0&#125;; //aecho $str&#123;3&#125;; //d//修改$str&#123;1&#125;=m; //amcdefecho $str; //只能修改一个字符,如果是中文,要输入3次//删除$str&#123;1&#125;='';echo $str; //长度不变,只是看不到//添加$str= 'abc';$str&#123;3&#125;='d'; //abcd, 空格长度只显示一个 [] 作用 对于字符串,跟{}类似 heredoc,跟双引号差不多12345678910111213141516$syusuke=&quot;abc&quot;;$table=&lt;&lt;&lt;EOF //这里可以不写双引号,&quot;EOF&quot; 也是可以的.&lt;table border=&apos;1&apos;&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;用户&lt;/td&gt; &lt;td&gt;描述&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;&#123;$syusuke&#125;&lt;/td&gt; &lt;td&gt;lolva;fasf&quot;asdf&quot;asdf&apos;a&apos;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;EOF;echo $table; nowdoc,单引号不能省,不解析变量,相当于单引号123$str=&lt;&lt;&lt;'EOD' //这里不能省 &lt;h1&gt;aaaa&lt;/h1&gt;EOD; 类型转换自动类型转换12345678910111213141516/* 数值-&gt;数值本身 boolean -&gt; true-&gt;1,false-&gt;空字符串 null -&gt; 空字符串*/echo 123;echo 34.05;$arr = array(12,2);echo $arr;//Array//资源$handle = fopen('a.txt','r');var_dump($handle);echo $handle;//对象不能直接转换成字符串 强制转换12345//settype($var,type);//gettype($var);$var = 12;settype($var,'string');var_dump($var);//字符串 临时转换123456$var = 123;//1,$res = (string)$var;//2$res = strval($var);var_dump($res,$var); 字符串转换成其他类型123456789101112131415161718//字符串转换成数字,以合法数值开始,取开始的数字,否则为0echo 2+'12ee';//14echo 3+'abc'; //0echo 3+'2e2'; //203$str=''; //false$str=0; //false$str=0.0; //false$str=null; //false$str=array(); //false$str='0'; //false --PS//其他的字符串有内容都是true$str=" "; //trueif($str)&#123; echo 'true';&#125;else&#123; echo 'false';&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP变量作用域]]></title>
      <url>%2F2017%2F02%2F07%2FPHP%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[变量作用域超全局变量1234567891011121314151617//打印所有的print_r($GLOBALS);$test = 'abc&lt;br/&gt;';$i =1;// print_r($GLOBALS);function abc()&#123; echo $GLOBALS['test']; //2.abc $GLOBALS['test'] = 'd&lt;br/&gt;';&#125;echo $test; //1.abcabc();echo $test; //3.d/*abcabcd*/ 全局变量global 全局变量一定不能在声明的时候赋值 全局变量一定不能在声明的时候赋值 只要全局函数定义就可以,可以不用管定义的代码的前后 12345678910$i=1;function func1()&#123; global $i; echo $i; $i++;&#125;func1();func1();echo $i;//123 函数内静态变量123456789function func1()&#123; static $i=1; echo $i; $i++;&#125;func1();func1();//12echo $i; //ERROR 函数内动态变量123456789function func1()&#123; $i=1; echo $i; $i++;&#125;func1();func1();//11echo $i; //ERROR 函数变量作用域123456&lt;?php $i=1,$j=2; function func1()&#123; echo $i,$j; //ERROR &#125;?&gt; 内部函数作用域1234567&lt;?php function func1()&#123; $i=1; echo $i; &#125;func1();echo $i; //ERROR]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 单例模式]]></title>
      <url>%2F2017%2F02%2F05%2FJava-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[JAVA 中用到单例模式 是我用到的,可能并不全 1.双重校验锁(我常用) 这种我经常用到 12345678910111213141516public class SSingleton &#123; private static SSingleton INSTANCE; public static SSingleton getInstance() &#123; if (INSTANCE == null) &#123; synchronized (SSingleton.class) &#123; if (INSTANCE == null) INSTANCE = new SSingleton(); &#125; &#125; return INSTANCE; &#125; private SSingleton() &#123; &#125;&#125; 2.枚举(很推荐) 这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象 1234567891011public enum ESingleton &#123; INSTANCE; private ESingleton() &#123; System.out.println(&quot;ESingleton&quot;); &#125; public void getI()&#123; System.out.println(&quot;asdf&quot;); &#125;&#125; 3.静态内部类 这种也比较常用 123456789101112public class SiSingleton &#123; private static class SingletonHolder &#123; private static final SiSingleton INSTANCE = new SiSingleton(); &#125; private SiSingleton() &#123; &#125; public static final SiSingleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 4.一种新的单例模式来自:http://www.jianshu.com/p/d9c9c947678a 123456789101112131415161718192021public class RxSingleton &#123; private static final AtomicReference&lt;RxSingleton&gt; INSTANCE = new AtomicReference&lt;RxSingleton&gt;(); private RxSingleton() &#123; &#125; public static RxSingleton getInstance() &#123; for (; ; ) &#123; RxSingleton current = INSTANCE.get(); if (current != null) &#123; return current; &#125; current = new RxSingleton(); if (INSTANCE.compareAndSet(null, current)) &#123; return current; &#125; &#125; &#125;&#125; AtomicReference 是作用是对”对象”进行原子操作。通过源码可以看出，它是通过 “volatile”和”Unsafe 提供的CAS（比较与交换，Compare and swap,是一种有名的无锁算法函数）实现原子操作。 CAShttps://www.ibm.com/developerworks/cn/java/j-jtp04186 current 是 volatile 类型。这保证了：当某线程修改value的值时，其他线程看到的value值都是最新的，即修改之后的volatile的值。 通过 CAS 设置 value。这保证了：当某线程池通过CAS函数(如compareAndSet函数)设置 value 时，它的操作是原子的，即线程在操作value时不会被中断。CAS是一种无阻塞的锁,采用不断比较设值的方式来避免并发问题,不会有锁的等待和上下文切换问题,性能消耗较小。 如果 当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 这种方式既能够保证延迟加载又能保证原子性及实例的唯一性，代码也相对比较简洁。 通过并发的学习与使用，线程的阻塞和上下文的切换会带来一定的性能开销，尤其在高并发的环境下。 而原子变量可以避免优先级倒置和死锁等危险，竞争比较便宜，协调发生在更细的粒度级别，允许更高程度的并行机制等等。 以下代码参考至:http://cantellow.iteye.com/blog/838473 5.饿汉12345678910public class EhSingleton &#123; private static EhSingleton instance = new EhSingleton(); private EhSingleton() &#123; &#125; public static EhSingleton getInstance() &#123; return instance; &#125;&#125; 6.懒汉线程不安全1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 线程安全,效率很低12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java IO 文件操作]]></title>
      <url>%2F2017%2F02%2F05%2FJava-IO-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[JAVA 文件操作 包括文件复制,移动,文件文件的读取,文件文件的写入 1.文件复制(1)直接复制 BufferedInputStream BufferedOutputStream FileInputStream FileOutputStream 没有缓冲区1234567891011121314151617181920212223public static void copyFile(String src, String dist) &#123; File srcFile = new File(src); File distFile = new File(dist); if (!srcFile.exists()) &#123; System.out.println(&quot;文件没找到!&quot;); return; &#125; try &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(distFile)); int b; while ((b = bis.read()) != -1) &#123; bos.write(b); &#125; bos.flush(); bos.close(); bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; (2)缓冲区1 BufferedInputStream BufferedOutputStream FileInputStream FileOutputStream byte[2048] 123456789101112131415161718192021222324public static void copyFileBuffered(String src, String dist) &#123; File srcFile = new File(src); File distFile = new File(dist); if (!srcFile.exists()) &#123; System.out.println(&quot;文件没找到!&quot;); return; &#125; try &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(distFile)); byte[] buf = new byte[2048]; int len; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); &#125; bos.flush(); bos.close(); bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; (3)缓冲区2 InputStream/FileInputStream OutputStream/FileInputStream byte[2048] 1234567891011121314151617181920212223242526public static void copyFileBuffered2(String src, String dist) &#123; File srcFile = new File(src); File distFile = new File(dist); if (!srcFile.exists()) &#123; System.out.println(&quot;文件没找到!&quot;); return; &#125; try &#123; //InputStream input = new FileInputStream(srcFile); //OutputStream output = new FileOutputStream(distFile); FileInputStream input = new FileInputStream(srcFile); FileOutputStream output = new FileOutputStream(distFile); byte[] buf = new byte[2048]; int bytesRead; while ((bytesRead = input.read(buf)) != -1) &#123; output.write(buf, 0, bytesRead); &#125; output.flush(); output.close(); input.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; NIO transferTo FileChannel FileInputStream FileOutputStream 12345678910111213141516171819public static void copyFileByNIOTo(String src, String dist) &#123; File srcFile = new File(src); File distFile = new File(dist); if (!srcFile.exists()) &#123; System.out.println(&quot;文件没找到!&quot;); return; &#125; try &#123; FileChannel fcin = new FileInputStream(srcFile).getChannel(); FileChannel fout = new FileOutputStream(distFile).getChannel(); fcin.transferTo(0, fcin.size(), fout); fcin.close(); fout.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; NIO transferFrom FileChannel FileInputStream FileOutputStream 12345678910111213141516171819public static void copyFileByNIOFrom(String src, String dist) &#123; File srcFile = new File(src); File distFile = new File(dist); if (!srcFile.exists()) &#123; System.out.println(&quot;文件没找到!&quot;); return; &#125; try &#123; FileChannel fcin = new FileInputStream(srcFile).getChannel(); FileChannel fout = new FileOutputStream(distFile).getChannel(); fout.transferFrom(fcin, 0, fcin.size()); fcin.close(); fout.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; Files.copy Files.copy1234567891011121314public static void copyFileByFiles(String src, String dist) &#123; File srcFile = new File(src); File distFile = new File(dist); if (!srcFile.exists()) &#123; System.out.println(&quot;文件没找到!&quot;); return; &#125; try &#123; Files.copy(srcFile.toPath(), distFile.toPath()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 最后的测试12345678910111213141516171819202122232425262728293031323334353637383940/** * copyFile():131929 * copyFileBuffered():29877 * copyFileBuffered2():43335 * copyFileByNIOTo():25877 * copyFileByNIOFrom():36073 * copyFileByFiles():51376 */public static void main(String[] args) &#123; long t = System.currentTimeMillis(); copyFile(&quot;C:\\Users\\syusu\\Desktop\\qw.mp4&quot;, &quot;C:\\Users\\syusu\\Desktop\\copyFile.mp4&quot;); System.out.println(&quot;copyFile():&quot; + (System.currentTimeMillis() - t)); t = System.currentTimeMillis(); copyFileBuffered(&quot;C:\\Users\\syusu\\Desktop\\qw.mp4&quot;, &quot;C:\\Users\\syusu\\Desktop\\copyFileBuffered.mp4&quot;); System.out.println(&quot;copyFileBuffered():&quot; + (System.currentTimeMillis() - t)); t = System.currentTimeMillis(); copyFileBuffered2(&quot;C:\\Users\\syusu\\Desktop\\qw.mp4&quot;, &quot;C:\\Users\\syusu\\Desktop\\copyFileBuffered2.mp4&quot;); System.out.println(&quot;copyFileBuffered2():&quot; + (System.currentTimeMillis() - t)); t = System.currentTimeMillis(); copyFileByNIOTo(&quot;C:\\Users\\syusu\\Desktop\\qw.mp4&quot;, &quot;C:\\Users\\syusu\\Desktop\\copyFileByNIOTo.mp4&quot;); System.out.println(&quot;copyFileByNIOTo():&quot; + (System.currentTimeMillis() - t)); t = System.currentTimeMillis(); copyFileByNIOFrom(&quot;C:\\Users\\syusu\\Desktop\\qw.mp4&quot;, &quot;C:\\Users\\syusu\\Desktop\\copyFileByNIOFrom.mp4&quot;); System.out.println(&quot;copyFileByNIOFrom():&quot; + (System.currentTimeMillis() - t)); t = System.currentTimeMillis(); copyFileByFiles(&quot;C:\\Users\\syusu\\Desktop\\qw.mp4&quot;, &quot;C:\\Users\\syusu\\Desktop\\copyFileByFiles.mp4&quot;); System.out.println(&quot;copyFileByFiles():&quot; + (System.currentTimeMillis() - t));&#125; Files 注意的地方 Files.copy(): 这个函数有3个重载函数 CopyOption StandardCopyOption ATOMIC_MOVE:Move the file as an atomic file system operation. COPY_ATTRIBUTES:Copy attributes to the new file. REPLACE_EXISTING:Replace an existing file if it exists. LinkOption NOFOLLOW_LINKS:Do not follow symbolic links. Files.copy,Files.move() 时,如果文件已经存在12Files.copy(srcFile.toPath(), distFile.toPath(), StandardCopyOption.REPLACE_EXISTING);Files.copy(srcFile.toPath(), distFile.toPath(), StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES); 文件删除12345// 要求文件存在,否则会报异常srcFile.delete();Files.delete(srcFile.toPath());// true:删除成功, false:删除失败/文件不存在boolean isDelete = Files.deleteIfExists(srcFile.toPath()); 文件移动 这个比较简单,只要在以上复制的完成后调用删除1234//删除Files.move(srcFile.toPath(), distFile.toPath());//如果已经存在,替换Files.move(srcFile.toPath(), distFile.toPath(),StandardCopyOption.REPLACE_EXISTING); 文件文本的读取1.文本文件复制字符流读写复制文件，仅限文本文件123456789101112131415161718192021222324252627282930public static void copyTxtFile1(String src, String dist) &#123; FileReader fr = null; FileWriter fw = null; try &#123; fr = new FileReader(src); fw = new FileWriter(dist);// int c;// while ((c = fr.read()) != -1) &#123;// fw.write(c);// &#125; char[] buf = new char[2048]; int len; while ((len = fr.read(buf)) != -1) &#123; fw.write(buf, 0, len); &#125; fw.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; fw.close(); fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.文本文件复制字符流缓冲区读写文件-高效，仅限文本文件123456789101112131415161718192021222324public static void copyTxtFile2(String src, String dist) &#123; BufferedReader br = null; BufferedWriter bw = null; try &#123; br = new BufferedReader(new FileReader(src)); bw = new BufferedWriter(new FileWriter(dist)); String line = &quot;&quot;; while ((line = br.readLine()) != null) &#123; bw.write(line); bw.newLine(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; bw.flush(); bw.close(); br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 文件文件-读取-写入写入1234567891011121314public static void readTxtFile(String src) &#123; try &#123; BufferedReader br = new BufferedReader(new FileReader(src)); String line = &quot;&quot;; StringBuffer sb = new StringBuffer(); while ((line = br.readLine()) != null) &#123; sb.append(line); sb.newLine(); &#125; System.out.println(sb.toString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 写入1234567891011121314151617181920212223public static void writeTxtFile(String dist) &#123; File distFile = new File(dist); if (!distFile.exists()) &#123; try &#123; distFile.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; try &#123; BufferedWriter bw = new BufferedWriter(new FileWriter(distFile)); bw.write(&quot;我是中国人....&quot;); bw.write(&quot;我是中国人....&quot;); bw.write(&quot;我是中国人....&quot;); bw.newLine(); bw.write(&quot;我是中国人....&quot;); bw.flush(); bw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 随机文件12345678910111213141516171819202122232425public static void readFileByRandomAccess(String fileName) &#123; RandomAccessFile raf = null; try &#123; //RandomAccessFile(fileName,模式); raf = new RandomAccessFile(fileName, &quot;r&quot;); long fileLength = raf.length(); //跳到第10 个起点 raf.seek(10); byte[] bytes = new byte[10]; int byteread = 0; while ((byteread = raf.read(bytes)) != -1) &#123; System.out.write(bytes, 0, byteread); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (raf != null) &#123; try &#123; raf.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[杭电ACM-Fibonacci数列]]></title>
      <url>%2F2017%2F02%2F03%2F%E6%9D%AD%E7%94%B5ACM-Fibonacci%E6%95%B0%E5%88%97%2F</url>
      <content type="text"><![CDATA[杭电ACM-Fibonacci数列这文章是我在[2014-11-22 18:58:24]写的,现在移到这个博客里的:原文地址 例如 费波那契数列（意大利语：Successione di Fibonacci），又译为费波拿契数、斐波那契数列、费氏数列、黄金分割数列。 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233 F0 = 0 F1 = 1 F2 = F(n-1)+F(n-2) [n&gt;=2] 这里的数比较大,所以,只要是小的数,就可以用递归来做,这里用到了 这个数列的一个公式: 由于题目要求,高于4位的输出四位,如果小于4位的数(小于1000)的数,也是可以用的,只是直接输出比较麻烦,所以,我们就可以,把小于4位的数直接输出,如果刚好是4位的(小于9999)的.如果也是通过递归算的,计算量比较大 代码如下12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;iomanip&gt;using namespace std;int fibo(int i)&#123; if (i == 0) return 0; else if (i == 1) return 1; return fibo(i - 1) + fibo(i - 2);&#125;int main()&#123; int n; while (cin &gt;&gt; n) &#123; //小于20 的直接算就可以 if (n&lt;=20) cout &lt;&lt; fibo(n) &lt;&lt; endl; else &#123; //大于20的,直接用公式 double a1 = -0.5*log10(5.0); double a2 = (1.0 + sqrt(5.0)) / 2.0; double a3 = n*log10(a2); a2 = a1 + a3; a2 = a2 - int(a2); double b = pow(10.0, a2); cout &lt;&lt; (int)(b*1000) &lt;&lt; endl; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[杭电ACM-Wooden Sticks]]></title>
      <url>%2F2016%2F12%2F24%2F%E6%9D%AD%E7%94%B5ACM-Wooden-Sticks%2F</url>
      <content type="text"><![CDATA[杭电ACM-Wooden Sticks这文章是我在[2014-11-26 09:06:52]写的,现在移到这个博客里的:原文地址 题目Wooden Sticks Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 2322 Accepted Submission(s): 905 Problem DescriptionThere is a pile of n wooden sticks. The length and weight of each stick are known in advance. The sticks are to be processed by a woodworking machine in one by one fashion. It needs some time, called setup time, for the machine to prepare processing a stick. The setup times are associated with cleaning operations and changing tools and shapes in the machine. The setup times of the woodworking machine are given as follows: (a) The setup time for the first wooden stick is 1 minute. (b) Right after processing a stick of length l and weight w , the machine will need no setup time for a stick of length l’ and weight w’ if l&lt;=l’ and w&lt;=w’. Otherwise, it will need 1 minute for setup. You are to find the minimum setup time to process a given pile of n wooden sticks. For example, if you have five sticks whose pairs of length and weight are (4,9), (5,2), (2,1), (3,5), and (1,4), then the minimum setup time should be 2 minutes since there is a sequence of pairs (1,4), (3,5), (4,9), (2,1), (5,2). InputThe input consists of T test cases. The number of test cases (T) is given in the first line of the input file. Each test case consists of two lines: The first line has an integer n , 1&lt;=n&lt;=5000, that represents the number of wooden sticks in the test case, and the second line contains n 2 positive integers l1, w1, l2, w2, …, ln, wn, each of magnitude at most 10000 , where li and wi are the length and weight of the i th wooden stick, respectively. The 2n integers are delimited by one or more spaces. OutputThe output should contain the minimum setup time in minutes, one per line. Sample Input354 9 5 2 2 1 3 5 1 432 2 1 1 2 231 3 2 2 3 1 Sample Output213 SourceAsia 2001, Taejon (South Korea) 我的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//锯木时间问题/* 我是先按长度排序,然后再先择重量符合要求,然后交换*/#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct Wooden&#123; int length; int weigth;&#125;;bool cmp(const Wooden &amp;a, const Wooden &amp;b)&#123; if (a.length != b.length) return a.length &lt; b.length; else return a.weigth &lt; b.weigth;&#125;int main()&#123; int T, n; Wooden ws[5001]; int flag[5001]; //标志是否被访问过 cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; ws[i].length &gt;&gt; ws[i].weigth; flag[i] = 0; &#125; sort(ws, ws + n, cmp); int time = 0; for (int i = 0; i &lt; n ; i++) &#123; if (flag[i] == 1) //跳过已经被访问过的元素 continue; int tempW = ws[i].weigth; for (int j = i + 1; j &lt; n; j++) &#123; //下面就是从以后的元素找重量最小的那个,类似于先择排序法 if (tempW &lt;= ws[j].weigth &amp;&amp; (flag[j] == 0)) &#123; tempW = ws[j].weigth; flag[j] = 1; &#125; &#125; time++; &#125; cout &lt;&lt; time &lt;&lt; endl; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android艺术探索第一章]]></title>
      <url>%2F2016%2F11%2F19%2FAndroid%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%AC%E4%B8%80%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[一.生命周期 onCreate: 初始化工作 onStart: 已经可见,但是没在前台,无法交互 onResume:已经可见而且可以交互 onPause: Activity正在停止,正常情况下onStop()会紧接着执行,如果快速再次回到Activity,就会执行onResume方法,这种情况比较极端.这里不适合耗时操作,可以存储数据,停止动画等操作, onStop: 即将停止.不能耗时操作 onDestory: Activity 就要被销毁,这是最后一个回调,做为资源的回收和资源的释放. onRestart: Activity正在启动,从从不可见变为可见 1.1 正常下的生命周期(1).第一次启动onCreate-&gt;onStart-&gt;onResume (2).打开新Activity或者Home时.onPause-&gt;onStop PS:新Activity 透明的主题,那么旧的Activity的onStop不会被执行 (3).再次回到ActivityonRestart-&gt;onStart-&gt;onResume (4).back键时onPause-&gt;onStop-&gt;onDestory onCreate &lt;=&gt; onDestory :Activity 的 创建 销毁 onStart &lt;=&gt; onStop Activity 可见上来说 onResume &lt;=&gt; onPause Activity 是否在前台 Activity A 启动 Activity B 的 生命周期 A:onPause B:onCreate B:onStart B:onResume A:onStop 1.2 异常下的生命周期 Configuration发生改变 (1)资源配置发生改变配置发生改变: Activity-&gt;意外发生-&gt;执行onSaveInstanceState-&gt;onDestoryonSaveInstanceState: 在onStop之前,但onPause之前或之后,都有可能 重建Activity: Activity-&gt;onCreate-&gt;onRestoreInstanceStateonRestoreInstanceState : 在onStart之后 (2)系统内存不足Activity优先级: 前台Activity 可见Activity,但非前台Activity,如Dialog 后台Activity 也可指定当系统配置发生改变时,不重建 Activity 常用配置locale | orientation| keyboardHidden123&lt;activityandorid:configChanges=&quot;locale|orientation|keyboardHidden&quot;&gt;&lt;/activity&gt; 二.Activity启动模式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello Hexo]]></title>
      <url>%2F2016%2F11%2F19%2Fhello-hexo%2F</url>
      <content type="text"><![CDATA[安装按照官网就可以我选择的主题是:next Config12345678910111213141516// Sitetitle: 琴声悠扬subtitle: As An Developer!description: 当你孤单你会想起谁?author: 琴声悠扬language: zh-Hanstimezone: Asia/Shanghaiavatar: /images/avatar.png 1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 创建tags,categories生成index.htmlhexo new page &quot;tags&quot;title: Tagcloud date: 2014-12-22 12:39:04 type: “tags” hexo new page &quot;categories&quot;title: Tagcloud date: 2014-12-22 12:39:04 type: “categories” 注意打开menu菜单下的注释 hexo ghexo d 就可以了.]]></content>
    </entry>

    
  
  
</search>
