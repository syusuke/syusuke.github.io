<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Java 单例模式]]></title>
      <url>%2F2017%2F02%2F05%2FJava-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[JAVA 中用到单例模式 是我用到的,可能并不全 1.双重校验锁(我常用) 这种我经常用到 12345678910111213141516public class SSingleton &#123; private static SSingleton INSTANCE; public static SSingleton getInstance() &#123; if (INSTANCE == null) &#123; synchronized (SSingleton.class) &#123; if (INSTANCE == null) INSTANCE = new SSingleton(); &#125; &#125; return INSTANCE; &#125; private SSingleton() &#123; &#125;&#125; 2.枚举(很推荐) 这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象 1234567891011public enum ESingleton &#123; INSTANCE; private ESingleton() &#123; System.out.println(&quot;ESingleton&quot;); &#125; public void getI()&#123; System.out.println(&quot;asdf&quot;); &#125;&#125; 3.静态内部类 这种也比较常用 123456789101112public class SiSingleton &#123; private static class SingletonHolder &#123; private static final SiSingleton INSTANCE = new SiSingleton(); &#125; private SiSingleton() &#123; &#125; public static final SiSingleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 4.一种新的单例模式来自:http://www.jianshu.com/p/d9c9c947678a 123456789101112131415161718192021public class RxSingleton &#123; private static final AtomicReference&lt;RxSingleton&gt; INSTANCE = new AtomicReference&lt;RxSingleton&gt;(); private RxSingleton() &#123; &#125; public static RxSingleton getInstance() &#123; for (; ; ) &#123; RxSingleton current = INSTANCE.get(); if (current != null) &#123; return current; &#125; current = new RxSingleton(); if (INSTANCE.compareAndSet(null, current)) &#123; return current; &#125; &#125; &#125;&#125; AtomicReference 是作用是对”对象”进行原子操作。通过源码可以看出，它是通过 “volatile”和”Unsafe 提供的CAS（比较与交换，Compare and swap,是一种有名的无锁算法函数）实现原子操作。 CAShttps://www.ibm.com/developerworks/cn/java/j-jtp04186 current 是 volatile 类型。这保证了：当某线程修改value的值时，其他线程看到的value值都是最新的，即修改之后的volatile的值。 通过 CAS 设置 value。这保证了：当某线程池通过CAS函数(如compareAndSet函数)设置 value 时，它的操作是原子的，即线程在操作value时不会被中断。CAS是一种无阻塞的锁,采用不断比较设值的方式来避免并发问题,不会有锁的等待和上下文切换问题,性能消耗较小。 如果 当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 这种方式既能够保证延迟加载又能保证原子性及实例的唯一性，代码也相对比较简洁。 通过并发的学习与使用，线程的阻塞和上下文的切换会带来一定的性能开销，尤其在高并发的环境下。 而原子变量可以避免优先级倒置和死锁等危险，竞争比较便宜，协调发生在更细的粒度级别，允许更高程度的并行机制等等。 以下代码参考至:http://cantellow.iteye.com/blog/838473 5.饿汉12345678910public class EhSingleton &#123; private static EhSingleton instance = new EhSingleton(); private EhSingleton() &#123; &#125; public static EhSingleton getInstance() &#123; return instance; &#125;&#125; 6.懒汉线程不安全1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 线程安全,效率很低12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java IO 文件操作]]></title>
      <url>%2F2017%2F02%2F05%2FJava-IO-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[JAVA 文件操作 包括文件复制,移动,文件文件的读取,文件文件的写入 1.文件复制(1)直接复制 BufferedInputStream BufferedOutputStream FileInputStream FileOutputStream 没有缓冲区1234567891011121314151617181920212223public static void copyFile(String src, String dist) &#123; File srcFile = new File(src); File distFile = new File(dist); if (!srcFile.exists()) &#123; System.out.println(&quot;文件没找到!&quot;); return; &#125; try &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(distFile)); int b; while ((b = bis.read()) != -1) &#123; bos.write(b); &#125; bos.flush(); bos.close(); bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; (2)缓冲区1 BufferedInputStream BufferedOutputStream FileInputStream FileOutputStream byte[2048] 123456789101112131415161718192021222324public static void copyFileBuffered(String src, String dist) &#123; File srcFile = new File(src); File distFile = new File(dist); if (!srcFile.exists()) &#123; System.out.println(&quot;文件没找到!&quot;); return; &#125; try &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(distFile)); byte[] buf = new byte[2048]; int len; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); &#125; bos.flush(); bos.close(); bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; (3)缓冲区2 InputStream/FileInputStream OutputStream/FileInputStream byte[2048] 1234567891011121314151617181920212223242526public static void copyFileBuffered2(String src, String dist) &#123; File srcFile = new File(src); File distFile = new File(dist); if (!srcFile.exists()) &#123; System.out.println(&quot;文件没找到!&quot;); return; &#125; try &#123; //InputStream input = new FileInputStream(srcFile); //OutputStream output = new FileOutputStream(distFile); FileInputStream input = new FileInputStream(srcFile); FileOutputStream output = new FileOutputStream(distFile); byte[] buf = new byte[2048]; int bytesRead; while ((bytesRead = input.read(buf)) != -1) &#123; output.write(buf, 0, bytesRead); &#125; output.flush(); output.close(); input.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; NIO transferTo FileChannel FileInputStream FileOutputStream 12345678910111213141516171819public static void copyFileByNIOTo(String src, String dist) &#123; File srcFile = new File(src); File distFile = new File(dist); if (!srcFile.exists()) &#123; System.out.println(&quot;文件没找到!&quot;); return; &#125; try &#123; FileChannel fcin = new FileInputStream(srcFile).getChannel(); FileChannel fout = new FileOutputStream(distFile).getChannel(); fcin.transferTo(0, fcin.size(), fout); fcin.close(); fout.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; NIO transferFrom FileChannel FileInputStream FileOutputStream 12345678910111213141516171819public static void copyFileByNIOFrom(String src, String dist) &#123; File srcFile = new File(src); File distFile = new File(dist); if (!srcFile.exists()) &#123; System.out.println(&quot;文件没找到!&quot;); return; &#125; try &#123; FileChannel fcin = new FileInputStream(srcFile).getChannel(); FileChannel fout = new FileOutputStream(distFile).getChannel(); fout.transferFrom(fcin, 0, fcin.size()); fcin.close(); fout.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; Files.copy Files.copy1234567891011121314public static void copyFileByFiles(String src, String dist) &#123; File srcFile = new File(src); File distFile = new File(dist); if (!srcFile.exists()) &#123; System.out.println(&quot;文件没找到!&quot;); return; &#125; try &#123; Files.copy(srcFile.toPath(), distFile.toPath()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 最后的测试12345678910111213141516171819202122232425262728293031323334353637383940/** * copyFile():131929 * copyFileBuffered():29877 * copyFileBuffered2():43335 * copyFileByNIOTo():25877 * copyFileByNIOFrom():36073 * copyFileByFiles():51376 */public static void main(String[] args) &#123; long t = System.currentTimeMillis(); copyFile(&quot;C:\\Users\\syusu\\Desktop\\qw.mp4&quot;, &quot;C:\\Users\\syusu\\Desktop\\copyFile.mp4&quot;); System.out.println(&quot;copyFile():&quot; + (System.currentTimeMillis() - t)); t = System.currentTimeMillis(); copyFileBuffered(&quot;C:\\Users\\syusu\\Desktop\\qw.mp4&quot;, &quot;C:\\Users\\syusu\\Desktop\\copyFileBuffered.mp4&quot;); System.out.println(&quot;copyFileBuffered():&quot; + (System.currentTimeMillis() - t)); t = System.currentTimeMillis(); copyFileBuffered2(&quot;C:\\Users\\syusu\\Desktop\\qw.mp4&quot;, &quot;C:\\Users\\syusu\\Desktop\\copyFileBuffered2.mp4&quot;); System.out.println(&quot;copyFileBuffered2():&quot; + (System.currentTimeMillis() - t)); t = System.currentTimeMillis(); copyFileByNIOTo(&quot;C:\\Users\\syusu\\Desktop\\qw.mp4&quot;, &quot;C:\\Users\\syusu\\Desktop\\copyFileByNIOTo.mp4&quot;); System.out.println(&quot;copyFileByNIOTo():&quot; + (System.currentTimeMillis() - t)); t = System.currentTimeMillis(); copyFileByNIOFrom(&quot;C:\\Users\\syusu\\Desktop\\qw.mp4&quot;, &quot;C:\\Users\\syusu\\Desktop\\copyFileByNIOFrom.mp4&quot;); System.out.println(&quot;copyFileByNIOFrom():&quot; + (System.currentTimeMillis() - t)); t = System.currentTimeMillis(); copyFileByFiles(&quot;C:\\Users\\syusu\\Desktop\\qw.mp4&quot;, &quot;C:\\Users\\syusu\\Desktop\\copyFileByFiles.mp4&quot;); System.out.println(&quot;copyFileByFiles():&quot; + (System.currentTimeMillis() - t));&#125; Files 注意的地方 Files.copy(): 这个函数有3个重载函数 CopyOption StandardCopyOption ATOMIC_MOVE:Move the file as an atomic file system operation. COPY_ATTRIBUTES:Copy attributes to the new file. REPLACE_EXISTING:Replace an existing file if it exists. LinkOption NOFOLLOW_LINKS:Do not follow symbolic links. Files.copy,Files.move() 时,如果文件已经存在12Files.copy(srcFile.toPath(), distFile.toPath(), StandardCopyOption.REPLACE_EXISTING);Files.copy(srcFile.toPath(), distFile.toPath(), StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES); 文件删除12345// 要求文件存在,否则会报异常srcFile.delete();Files.delete(srcFile.toPath());// true:删除成功, false:删除失败/文件不存在boolean isDelete = Files.deleteIfExists(srcFile.toPath()); 文件移动 这个比较简单,只要在以上复制的完成后调用删除1234//删除Files.move(srcFile.toPath(), distFile.toPath());//如果已经存在,替换Files.move(srcFile.toPath(), distFile.toPath(),StandardCopyOption.REPLACE_EXISTING); 文件文本的读取1.文本文件复制字符流读写复制文件，仅限文本文件123456789101112131415161718192021222324252627282930public static void copyTxtFile1(String src, String dist) &#123; FileReader fr = null; FileWriter fw = null; try &#123; fr = new FileReader(src); fw = new FileWriter(dist);// int c;// while ((c = fr.read()) != -1) &#123;// fw.write(c);// &#125; char[] buf = new char[2048]; int len; while ((len = fr.read(buf)) != -1) &#123; fw.write(buf, 0, len); &#125; fw.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; fw.close(); fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.文本文件复制字符流缓冲区读写文件-高效，仅限文本文件123456789101112131415161718192021222324public static void copyTxtFile2(String src, String dist) &#123; BufferedReader br = null; BufferedWriter bw = null; try &#123; br = new BufferedReader(new FileReader(src)); bw = new BufferedWriter(new FileWriter(dist)); String line = &quot;&quot;; while ((line = br.readLine()) != null) &#123; bw.write(line); bw.newLine(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; bw.flush(); bw.close(); br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 文件文件-读取-写入写入1234567891011121314public static void readTxtFile(String src) &#123; try &#123; BufferedReader br = new BufferedReader(new FileReader(src)); String line = &quot;&quot;; StringBuffer sb = new StringBuffer(); while ((line = br.readLine()) != null) &#123; sb.append(line); sb.newLine(); &#125; System.out.println(sb.toString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 写入1234567891011121314151617181920212223public static void writeTxtFile(String dist) &#123; File distFile = new File(dist); if (!distFile.exists()) &#123; try &#123; distFile.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; try &#123; BufferedWriter bw = new BufferedWriter(new FileWriter(distFile)); bw.write(&quot;我是中国人....&quot;); bw.write(&quot;我是中国人....&quot;); bw.write(&quot;我是中国人....&quot;); bw.newLine(); bw.write(&quot;我是中国人....&quot;); bw.flush(); bw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 随机文件12345678910111213141516171819202122232425public static void readFileByRandomAccess(String fileName) &#123; RandomAccessFile raf = null; try &#123; //RandomAccessFile(fileName,模式); raf = new RandomAccessFile(fileName, &quot;r&quot;); long fileLength = raf.length(); //跳到第10 个起点 raf.seek(10); byte[] bytes = new byte[10]; int byteread = 0; while ((byteread = raf.read(bytes)) != -1) &#123; System.out.write(bytes, 0, byteread); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (raf != null) &#123; try &#123; raf.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[杭电ACM-Fibonacci数列]]></title>
      <url>%2F2017%2F02%2F03%2F%E6%9D%AD%E7%94%B5ACM-Fibonacci%E6%95%B0%E5%88%97%2F</url>
      <content type="text"><![CDATA[杭电ACM-Fibonacci数列这文章是我在[2014-11-22 18:58:24]写的,现在移到这个博客里的:原文地址 例如 费波那契数列（意大利语：Successione di Fibonacci），又译为费波拿契数、斐波那契数列、费氏数列、黄金分割数列。 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233 F0 = 0 F1 = 1 F2 = F(n-1)+F(n-2) [n&gt;=2] 这里的数比较大,所以,只要是小的数,就可以用递归来做,这里用到了 这个数列的一个公式: 由于题目要求,高于4位的输出四位,如果小于4位的数(小于1000)的数,也是可以用的,只是直接输出比较麻烦,所以,我们就可以,把小于4位的数直接输出,如果刚好是4位的(小于9999)的.如果也是通过递归算的,计算量比较大 代码如下12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;iomanip&gt;using namespace std;int fibo(int i)&#123; if (i == 0) return 0; else if (i == 1) return 1; return fibo(i - 1) + fibo(i - 2);&#125;int main()&#123; int n; while (cin &gt;&gt; n) &#123; //小于20 的直接算就可以 if (n&lt;=20) cout &lt;&lt; fibo(n) &lt;&lt; endl; else &#123; //大于20的,直接用公式 double a1 = -0.5*log10(5.0); double a2 = (1.0 + sqrt(5.0)) / 2.0; double a3 = n*log10(a2); a2 = a1 + a3; a2 = a2 - int(a2); double b = pow(10.0, a2); cout &lt;&lt; (int)(b*1000) &lt;&lt; endl; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[杭电ACM-Wooden Sticks]]></title>
      <url>%2F2016%2F12%2F24%2F%E6%9D%AD%E7%94%B5ACM-Wooden-Sticks%2F</url>
      <content type="text"><![CDATA[杭电ACM-Wooden Sticks这文章是我在[2014-11-26 09:06:52]写的,现在移到这个博客里的:原文地址 题目Wooden Sticks Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 2322 Accepted Submission(s): 905 Problem DescriptionThere is a pile of n wooden sticks. The length and weight of each stick are known in advance. The sticks are to be processed by a woodworking machine in one by one fashion. It needs some time, called setup time, for the machine to prepare processing a stick. The setup times are associated with cleaning operations and changing tools and shapes in the machine. The setup times of the woodworking machine are given as follows: (a) The setup time for the first wooden stick is 1 minute. (b) Right after processing a stick of length l and weight w , the machine will need no setup time for a stick of length l’ and weight w’ if l&lt;=l’ and w&lt;=w’. Otherwise, it will need 1 minute for setup. You are to find the minimum setup time to process a given pile of n wooden sticks. For example, if you have five sticks whose pairs of length and weight are (4,9), (5,2), (2,1), (3,5), and (1,4), then the minimum setup time should be 2 minutes since there is a sequence of pairs (1,4), (3,5), (4,9), (2,1), (5,2). InputThe input consists of T test cases. The number of test cases (T) is given in the first line of the input file. Each test case consists of two lines: The first line has an integer n , 1&lt;=n&lt;=5000, that represents the number of wooden sticks in the test case, and the second line contains n 2 positive integers l1, w1, l2, w2, …, ln, wn, each of magnitude at most 10000 , where li and wi are the length and weight of the i th wooden stick, respectively. The 2n integers are delimited by one or more spaces. OutputThe output should contain the minimum setup time in minutes, one per line. Sample Input354 9 5 2 2 1 3 5 1 432 2 1 1 2 231 3 2 2 3 1 Sample Output213 SourceAsia 2001, Taejon (South Korea) 我的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//锯木时间问题/* 我是先按长度排序,然后再先择重量符合要求,然后交换*/#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct Wooden&#123; int length; int weigth;&#125;;bool cmp(const Wooden &amp;a, const Wooden &amp;b)&#123; if (a.length != b.length) return a.length &lt; b.length; else return a.weigth &lt; b.weigth;&#125;int main()&#123; int T, n; Wooden ws[5001]; int flag[5001]; //标志是否被访问过 cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; ws[i].length &gt;&gt; ws[i].weigth; flag[i] = 0; &#125; sort(ws, ws + n, cmp); int time = 0; for (int i = 0; i &lt; n ; i++) &#123; if (flag[i] == 1) //跳过已经被访问过的元素 continue; int tempW = ws[i].weigth; for (int j = i + 1; j &lt; n; j++) &#123; //下面就是从以后的元素找重量最小的那个,类似于先择排序法 if (tempW &lt;= ws[j].weigth &amp;&amp; (flag[j] == 0)) &#123; tempW = ws[j].weigth; flag[j] = 1; &#125; &#125; time++; &#125; cout &lt;&lt; time &lt;&lt; endl; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android艺术探索第一章]]></title>
      <url>%2F2016%2F11%2F19%2FAndroid%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%AC%E4%B8%80%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[一.生命周期 onCreate: 初始化工作 onStart: 已经可见,但是没在前台,无法交互 onResume:已经可见而且可以交互 onPause: Activity正在停止,正常情况下onStop()会紧接着执行,如果快速再次回到Activity,就会执行onResume方法,这种情况比较极端.这里不适合耗时操作,可以存储数据,停止动画等操作, onStop: 即将停止.不能耗时操作 onDestory: Activity 就要被销毁,这是最后一个回调,做为资源的回收和资源的释放. onRestart: Activity正在启动,从从不可见变为可见 1.1 正常下的生命周期(1).第一次启动onCreate-&gt;onStart-&gt;onResume (2).打开新Activity或者Home时.onPause-&gt;onStop PS:新Activity 透明的主题,那么旧的Activity的onStop不会被执行 (3).再次回到ActivityonRestart-&gt;onStart-&gt;onResume (4).back键时onPause-&gt;onStop-&gt;onDestory onCreate &lt;=&gt; onDestory :Activity 的 创建 销毁 onStart &lt;=&gt; onStop Activity 可见上来说 onResume &lt;=&gt; onPause Activity 是否在前台 Activity A 启动 Activity B 的 生命周期 A:onPause B:onCreate B:onStart B:onResume A:onStop 1.2 异常下的生命周期 Configuration发生改变 (1)资源配置发生改变配置发生改变: Activity-&gt;意外发生-&gt;执行onSaveInstanceState-&gt;onDestoryonSaveInstanceState: 在onStop之前,但onPause之前或之后,都有可能 重建Activity: Activity-&gt;onCreate-&gt;onRestoreInstanceStateonRestoreInstanceState : 在onStart之后 (2)系统内存不足Activity优先级: 前台Activity 可见Activity,但非前台Activity,如Dialog 后台Activity 也可指定当系统配置发生改变时,不重建 Activity 常用配置locale | orientation| keyboardHidden123&lt;activityandorid:configChanges=&quot;locale|orientation|keyboardHidden&quot;&gt;&lt;/activity&gt; 二.Activity启动模式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello Hexo]]></title>
      <url>%2F2016%2F11%2F19%2Fhello-hexo%2F</url>
      <content type="text"><![CDATA[安装按照官网就可以我选择的主题是:next Config12345678910111213141516// Sitetitle: 琴声悠扬subtitle: As An Developer!description: 当你孤单你会想起谁?author: 琴声悠扬language: zh-Hanstimezone: Asia/Shanghaiavatar: /images/avatar.png 1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 创建tags,categories生成index.htmlhexo new page &quot;tags&quot;title: Tagcloud date: 2014-12-22 12:39:04 type: “tags” hexo new page &quot;categories&quot;title: Tagcloud date: 2014-12-22 12:39:04 type: “categories” 注意打开menu菜单下的注释 hexo ghexo d 就可以了.]]></content>
    </entry>

    
  
  
</search>
